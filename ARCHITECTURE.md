# 🏗️ Архитектура NLThinkingPanel Pro

## Обзор

NLThinkingPanel Pro построен на модульной архитектуре с чёткой separation of concerns. Проект разделён на несколько слоёв, каждый из которых отвечает за свою область функциональности.

## Структура слоёв

```
┌─────────────────────────────────────────┐
│         main.py (Entry Point)           │
│         Инициализация и запуск          │
└────────────┬────────────────────────────┘
             │
┌────────────▼────────────────────────────┐
│         Cogs Layer (Commands)           │
│    ai_commands.py, admin.py, etc.       │
│    Обработка команд пользователей       │
└────────────┬────────────────────────────┘
             │
┌────────────▼────────────────────────────┐
│       Modules Layer (Business Logic)    │
│  ai_provider, context_builder, analytics│
│      Бизнес-логика и обработка          │
└────────────┬────────────────────────────┘
             │
┌────────────▼────────────────────────────┐
│        Core Layer (Infrastructure)      │
│   logger, cache, rate_limiter           │
│   Базовая инфраструктура системы        │
└────────────┬────────────────────────────┘
             │
┌────────────▼────────────────────────────┐
│      Config Layer (Configuration)       │
│         config.py, .env                 │
│     Централизованная конфигурация       │
└─────────────────────────────────────────┘
```

## Компоненты системы

### 1. Entry Point (`main.py`)

**Ответственность:**
- Инициализация бота
- Валидация конфигурации
- Загрузка Cogs
- Обработка глобальных событий
- Фоновые задачи (cleanup)

**Ключевые классы:**
- `NLThinkingPanelBot` - основной класс бота

### 2. Cogs Layer

#### `ai_commands.py`
**Ответственность:**
- Команды взаимодействия с AI (`!ask`, `!quick`, `!context`)
- Обработка сообщений для истории
- Разбивка длинных ответов

**Ключевые методы:**
- `ask()` - полный запрос с контекстом
- `quick()` - быстрый запрос без контекста
- `show_context()` - отображение текущего контекста

#### `admin.py`
**Ответственность:**
- Административные команды
- Просмотр статистики
- Управление кэшем и лимитами

**Ключевые методы:**
- `stats()` - общая статистика
- `report()` - отчёты за период
- `clear_cache()` - очистка кэша
- `my_stats()` - личная статистика пользователя

### 3. Modules Layer

#### `ai_provider.py`
**Ответственность:**
- Взаимодействие с OpenRouter API
- Retry logic и fallback модели
- Оптимизация промптов
- Кэширование ответов

**Ключевые возможности:**
- Автоматическое переключение на резервные модели
- Оценка количества токенов
- Умное сжатие длинных промптов

#### `context_builder.py`
**Ответственность:**
- Построение контекста сервера
- Отслеживание активности пользователей
- История сообщений
- Статистика активности

**Ключевые методы:**
- `build_full_context()` - полный контекст для AI
- `build_user_context()` - информация о пользователях
- `get_message_history()` - история сообщений
- `add_message()` - добавление сообщения в историю

#### `analytics.py`
**Ответственность:**
- Сбор метрик использования
- Статистика по пользователям и моделям
- Генерация отчётов
- Логирование ошибок

**Хранимые данные:**
- Общее количество запросов
- Использование токенов
- Статистика по пользователям
- Дневная статистика
- История ошибок

### 4. Core Layer

#### `logger.py`
**Ответственность:**
- Централизованное логирование
- Цветной вывод в консоль
- Ротация файлов логов

**Возможности:**
- Разные уровни логирования (DEBUG, INFO, WARNING, ERROR)
- Автоматическая ротация (макс 10MB на файл)
- Хранение последних 5 файлов

#### `cache.py`
**Ответственность:**
- Кэширование ответов AI
- TTL (Time To Live) управление
- Статистика кэша (hit rate)

**Ключевые возможности:**
- Thread-safe реализация
- Автоматическая очистка устаревших записей
- Генерация уникальных ключей на основе аргументов

#### `rate_limiter.py`
**Ответственность:**
- Защита от спама
- Sliding window алгоритм
- Управление лимитами

**Ключевые возможности:**
- Настраиваемые лимиты на пользователя
- Информация о времени сброса
- Админ-функции для сброса лимитов

### 5. Config Layer

#### `config.py`
**Ответственность:**
- Централизованная конфигурация
- Валидация настроек
- Типизация параметров

**Основные параметры:**
- Discord и OpenRouter настройки
- AI параметры (модель, температура, токены)
- Кэширование и rate limiting
- Аналитика и логирование
- Список администраторов

## Потоки данных

### Поток обработки команды `!ask`

```
1. Пользователь → Discord → Bot
   ↓
2. ai_commands.ask()
   ↓
3. Rate Limiter Check
   ↓ (если OK)
4. Context Builder → Построение контекста
   ↓
5. AI Provider → Проверка кэша
   ↓ (если не в кэше)
6. OpenRouter API → Генерация ответа
   ↓
7. Analytics → Логирование метрик
   ↓
8. Response → Пользователь
```

### Поток построения контекста

```
1. Context Builder
   ↓
2. Guild Members → Статусы и активность
   ↓
3. Message History → Последние сообщения
   ↓
4. Statistics → Подсчёт активности
   ↓
5. Formatted Context → AI Provider
```

## Паттерны проектирования

### 1. Singleton Pattern
Используется для глобальных экземпляров:
- `config` - конфигурация
- `logger` - логгер
- `cache` - кэш
- `rate_limiter` - rate limiter
- `analytics` - аналитика
- `context_builder` - построитель контекста
- `ai_provider` - AI провайдер

### 2. Strategy Pattern
`AIProvider` использует стратегию fallback моделей:
- Попытка основной модели
- При неудаче - переключение на резервные
- Retry logic с задержками

### 3. Observer Pattern
Discord.py Cogs система:
- Подписка на события (`on_message`, `on_ready`)
- Автоматическая загрузка расширений

### 4. Builder Pattern
`ContextBuilder`:
- Пошаговое построение сложного контекста
- Комбинирование различных источников данных

## Расширяемость

### Добавление новой команды

1. Создайте файл в `cogs/`:
```python
from discord.ext import commands

class NewCommands(commands.Cog):
    def __init__(self, bot):
        self.bot = bot
    
    @commands.command(name='mycommand')
    async def my_command(self, ctx):
        await ctx.send("Hello!")

async def setup(bot):
    await bot.add_cog(NewCommands(bot))
```

2. Бот автоматически загрузит новый Cog при запуске

### Добавление нового модуля

1. Создайте файл в `modules/`:
```python
class MyModule:
    def __init__(self):
        self.data = {}
    
    def process(self, input_data):
        # Ваша логика
        return result

# Глобальный экземпляр
my_module = MyModule()
```

2. Импортируйте в нужных Cogs:
```python
from modules.my_module import my_module
```

### Добавление новой модели AI

В `.env`:
```env
OPENROUTER_MODEL=новая/модель
```

Или программно в `ai_provider.py`:
```python
self.fallback_models.append('новая/модель')
```

## Безопасность

### 1. Rate Limiting
- Защита от спама на уровне пользователя
- Настраиваемые лимиты через `.env`
- Админы могут сбрасывать лимиты

### 2. Валидация
- Проверка конфигурации при запуске
- Валидация входных данных
- Обработка ошибок на всех уровнях

### 3. Логирование
- Все действия логируются
- Отслеживание ошибок
- Аудит использования

## Производительность

### 1. Кэширование
- Ответы AI кэшируются с TTL
- Снижение нагрузки на API
- Экономия токенов

### 2. Асинхронность
- Все операции асинхронные
- Параллельная обработка запросов
- Неблокирующий I/O

### 3. Оптимизация
- Автоматическое сжатие длинных промптов
- Оценка токенов перед запросом
- Ограничение размера истории

## Мониторинг

### Метрики
- Общее количество запросов
- Использование токенов
- Hit rate кэша
- Время ответа
- Количество ошибок

### Логи
- Цветной вывод в консоль
- Файловое логирование с ротацией
- Разные уровни важности

### Аналитика
- Статистика по пользователям
- Статистика по моделям
- Дневные отчёты
- Топ пользователей

## Рекомендации по развитию

### Краткосрочные улучшения
1. Добавить команду для изменения модели "на лету"
2. Реализовать систему плагинов
3. Добавить веб-панель администратора
4. Интеграция с базой данных (PostgreSQL/MongoDB)

### Долгосрочные улучшения
1. Мультиязычность интерфейса
2. Система ролей и прав доступа
3. A/B тестирование промптов
4. Интеграция с другими AI сервисами
5. Система обучения на feedback пользователей

## Заключение

Архитектура NLThinkingPanel Pro спроектирована с учётом:
- **Модульности** - легко добавлять новые функции
- **Масштабируемости** - готовность к росту нагрузки
- **Надёжности** - обработка ошибок на всех уровнях
- **Производительности** - кэширование и оптимизация
- **Безопасности** - rate limiting и валидация
- **Мониторинга** - детальная аналитика и логирование

Это делает проект готовым к коммерческому использованию и дальнейшему развитию.
